"""
Complyo Backend - Mit OpenRouter AI Integration
Website Compliance Scanner & API
"""
import os
import json
import httpx
import asyncio
from datetime import datetime
from typing import Dict, Any, List
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn
from fastapi import FastAPI, Depends
from .auth_routes import router as auth_router, init_db as init_auth_db
from .payment_routes import router as payment_router, init_db as init_payment_db
from .report_generator import router as report_router, init_db as init_report_db

app = FastAPI()

@app.on_event("startup")
async def startup():
    # Verbindung zur Datenbank herstellen
    await database.connect()
    
    # Datenbankschema initialisieren
    await init_auth_db()
    await init_payment_db()
    await init_report_db()

app.include_router(auth_router, prefix="/api", tags=["auth"])
app.include_router(payment_router, prefix="/api", tags=["payment"])
app.include_router(report_router, prefix="/api/reports", tags=["reports"])

# FastAPI App initialisieren
app = FastAPI(
    title="Complyo Backend",
    description="Website Compliance Scanner & Management API",
    version="2.0.0"
)

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In Production einschränken
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =====================================
# OPENROUTER AI SERVICE
# =====================================

class OpenRouterService:
    """OpenRouter API Client für AI-gestützte Compliance-Analyse"""
    
    def __init__(self):
        self.api_key = os.getenv("OPENROUTER_API_KEY")
        self.base_url = "https://openrouter.ai/api/v1"
        
        # Model-Selection für verschiedene Tasks
        self.models = {
            "legal_analysis": "anthropic/claude-sonnet-4",
            "text_generation": "openai/gpt-4o-mini",
            "code_generation": "anthropic/claude-sonnet-4"
        }
        
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "https://complyo.tech",
            "X-Title": "Complyo"
        }
    
    async def analyze_compliance(self, url: str, html_content: str = "") -> Dict[str, Any]:
        """
        AI-gestützte Compliance-Analyse einer Website
        """
        if not self.api_key or self.api_key == "your-openrouter-key":
            # Fallback auf Mock-Daten wenn kein API-Key
            return self._mock_analysis(url)
        
        prompt = f"""
        Analysiere die Website {url} auf deutsche Rechts-Compliance:
        
        Prüfe folgende Punkte:
        1. Impressum (TMG §5): Vollständigkeit und Rechtmäßigkeit
        2. Datenschutzerklärung (DSGVO Art. 13/14): Vorhandensein und Qualität  
        3. Cookie-Banner (TTDSG §25): DSGVO-Konformität
        4. SSL-Verschlüsselung: Sicherheitsaspekte
        5. Allgemeine Abmahn-Risiken
        
        Bewerte jeden Punkt mit: "ok", "warning", "error"
        Gib konkrete Handlungsempfehlungen und schätze Abmahn-Risiko in Euro.
        
        Antwort als JSON mit: compliance_score (0-100), findings, recommendations, estimated_risk
        """
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.base_url}/chat/completions",
                    headers=self.headers,
                    json={
                        "model": self.models["legal_analysis"],
                        "messages": [
                            {
                                "role": "system", 
                                "content": "Du bist ein Experte für deutsches Internetrecht und DSGVO-Compliance. Antworte präzise und praxisorientiert."
                            },
                            {
                                "role": "user",
                                "content": prompt
                            }
                        ],
                        "temperature": 0.1,
                        "max_tokens": 1500
                    }
                )
                
                if response.status_code == 200:
                    result = response.json()
                    ai_response = result["choices"][0]["message"]["content"]
                    
                    # Parse AI-Response zu strukturierten Daten
                    return self._parse_ai_response(ai_response, url)
                else:
                    print(f"OpenRouter API Error: {response.status_code} - {response.text}")
                    return self._mock_analysis(url)
                    
        except Exception as e:
            print(f"AI Analysis Error: {str(e)}")
            return self._mock_analysis(url)
    
    def _parse_ai_response(self, ai_response: str, url: str) -> Dict[str, Any]:
        """Parse AI-Response zu strukturierten Compliance-Daten"""
        
        # Versuche JSON aus AI-Response zu extrahieren
        try:
            # Einfache JSON-Extraktion (kann verbessert werden)
            import re
            json_match = re.search(r'\{.*\}', ai_response, re.DOTALL)
            if json_match:
                parsed = json.loads(json_match.group())
                return self._format_analysis_result(parsed, url)
        except:
            pass
        
        # Fallback: Strukturiere Text-Response
        return {
            "url": url,
            "scan_id": f"ai_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            "timestamp": datetime.now().isoformat(),
            "compliance_score": 60,  # Default bei Parse-Fehlern
            "status": "completed",
            "ai_analysis": ai_response,
            "source": "openrouter_ai"
        }
    
    def _format_analysis_result(self, parsed: Dict, url: str) -> Dict[str, Any]:
        """Formatiere AI-Analyse zu Standard-Format"""
        
        return {
            "url": url,
            "scan_id": f"ai_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            "timestamp": datetime.now().isoformat(),
            "compliance_score": parsed.get("compliance_score", 70),
            "status": "completed",
            "findings": parsed.get("findings", {}),
            "recommendations": parsed.get("recommendations", []),
            "estimated_risk": parsed.get("estimated_risk", {
                "abmahn_potential": "mittel",
                "estimated_cost": "1.000-3.000€"
            }),
            "source": "openrouter_ai"
        }
    
    def _mock_analysis(self, url: str) -> Dict[str, Any]:
        """Fallback Mock-Analyse wenn AI nicht verfügbar"""
        return {
            "url": url,
            "scan_id": f"mock_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            "timestamp": datetime.now().isoformat(),
            "compliance_score": 75,
            "status": "completed",
            "findings": {
                "impressum": {
                    "status": "warning",
                    "message": "Impressum gefunden, aber möglicherweise unvollständig",
                    "priority": "high"
                },
                "datenschutz": {
                    "status": "error", 
                    "message": "Datenschutzerklärung fehlt oder nicht auffindbar",
                    "priority": "critical"
                },
                "cookies": {
                    "status": "warning",
                    "message": "Cookie-Banner vorhanden, DSGVO-Konformität prüfen",
                    "priority": "high"
                },
                "ssl": {
                    "status": "ok",
                    "message": "SSL-Zertifikat aktiv",
                    "priority": "low"
                }
            },
            "recommendations": [
                "Impressum auf Vollständigkeit prüfen (§5 TMG)",
                "DSGVO-konforme Datenschutzerklärung erstellen", 
                "Cookie-Banner nach TTDSG optimieren",
                "Regelmäßige Compliance-Checks einrichten"
            ],
            "estimated_risk": {
                "abmahn_potential": "hoch",
                "estimated_cost": "2.000-5.000€",
                "urgency": "innerhalb 7 Tage beheben"
            },
            "source": "mock_fallback"
        }

# AI Service initialisieren
ai_service = OpenRouterService()

# =====================================
# BASIC ENDPOINTS
# =====================================

@app.get("/")
async def root():
    """Root endpoint - API Status"""
    return {
        "message": "Complyo Backend API",
        "status": "online", 
        "version": "2.0.0",
        "ai_enabled": bool(os.getenv("OPENROUTER_API_KEY") and os.getenv("OPENROUTER_API_KEY") != "your-openrouter-key"),
        "timestamp": datetime.now().isoformat()
    }

@app.get("/health")
async def health_check():
    """Health Check für Load Balancer"""
    return {
        "status": "healthy",
        "service": "complyo-backend",
        "version": "2.0.0",
        "timestamp": datetime.now().isoformat(),
        "environment": os.getenv("ENVIRONMENT", "development")
    }

@app.get("/api/status")
async def api_status():
    """Detaillierter API Status"""
    return {
        "api_version": "2.0.0",
        "status": "operational",
        "features": {
            "website_scanner": "active",
            "ai_analysis": "active" if ai_service.api_key and ai_service.api_key != "your-openrouter-key" else "mock_mode",
            "database": "connected" if os.getenv("DATABASE_URL") else "not_configured",
            "redis": "connected" if os.getenv("REDIS_HOST") else "not_configured"
        },
        "timestamp": datetime.now().isoformat()
    }

# =====================================
# AI-POWERED WEBSITE ANALYSIS
# =====================================

@app.post("/api/analyze")
async def analyze_website(request: dict, background_tasks: BackgroundTasks):
    """
    KI-gestützte Website Compliance Analyse
    POST /api/analyze
    Body: {"url": "https://example.com"}
    """
    url = request.get("url")
    if not url:
        raise HTTPException(status_code=400, detail="URL ist erforderlich")
    
    # URL-Validierung
    if not url.startswith(("http://", "https://")):
        url = "https://" + url
    
    try:
        # AI-gestützte Analyse
        analysis_result = await ai_service.analyze_compliance(url)
        
        # Optional: Background Task für erweiterte Analyse
        background_tasks.add_task(log_analysis, url, analysis_result)
        
        return analysis_result
        
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Analyse fehlgeschlagen: {str(e)}"
        )

@app.get("/api/projects")
async def get_projects():
    """Alle Projekte abrufen"""
    return {
        "projects": [
            {
                "id": "proj_001",
                "name": "Beispiel Website",
                "url": "https://example.com", 
                "compliance_score": 75,
                "last_scan": datetime.now().isoformat(),
                "status": "needs_attention"
            }
        ],
        "total": 1
    }

# =====================================
# AI TEXT GENERATION ENDPOINTS
# =====================================

@app.post("/api/generate/impressum")
async def generate_impressum(request: dict):
    """
    KI-generiertes Impressum
    Body: {"company_name": "...", "address": "...", "email": "..."}
    """
    if not ai_service.api_key or ai_service.api_key == "your-openrouter-key":
        raise HTTPException(
            status_code=503, 
            detail="AI-Service nicht verfügbar - OpenRouter API-Key fehlt"
        )
    
    # Hier würde die AI-gestützte Impressum-Generierung implementiert
    return {
        "message": "Impressum-Generierung implementiert mit OpenRouter AI",
        "status": "ready_for_implementation"
    }

@app.post("/api/generate/datenschutz")
async def generate_privacy_policy(request: dict):
    """KI-generierte Datenschutzerklärung"""
    if not ai_service.api_key or ai_service.api_key == "your-openrouter-key":
        raise HTTPException(
            status_code=503,
            detail="AI-Service nicht verfügbar - OpenRouter API-Key fehlt"
        )
    
    return {
        "message": "Datenschutz-Generierung implementiert mit OpenRouter AI", 
        "status": "ready_for_implementation"
    }

# =====================================
# BACKGROUND TASKS
# =====================================

def log_analysis(url: str, result: dict):
    """Background Task für Analyse-Logging"""
    print(f"[ANALYSIS LOG] {url} - Score: {result.get('compliance_score', 'N/A')}")

# =====================================
# SERVER START
# =====================================

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8002))
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=port,
        reload=False,
        log_level="info"
    )